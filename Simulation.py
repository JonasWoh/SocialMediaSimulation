import random
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import math


# random.seed(1)  # seed for reproducibility


class Virus:
    # constructor
    # number, attack_rate and cure_rate set the corresponding attributes
    # pay sets value_per_infected (only necessary if the payout is used as a factor in the simulation)
    # privacy sets the privacy_level (if privacy is used as a factor in the simulation)
    def __init__(self, number, attack_rate, cure_rate, pay=1, privacy=-1):
        self.number = number
        self.attack_rate = attack_rate  # percent chance for each infected node of infecting a neighboring node in the
        # next step
        # this is the parameter called 'beta' in the Bachelor's Thesis

        self.cure_rate = cure_rate  # percent chance of an infected node being cured in the next step
        # this is the parameter called 'delta' in the Bachelor's Thesis

        self.infected = []  # array containing the list of nodes infected by this virus
        self.value_per_infected = pay  # signifies the value of each node for the virus
        self.payout = 0  # stores the total value generated by the virus
        self.privacy_level = 0  # an int between 0 (low) and 100 (high) representing the level of exploitation of
        # user data
        # this is the parameter called 'x' in the Bachelor's Thesis
        self.set_privacy_level(privacy)

    def set_privacy_level(self, new_privacy):
        if 100 >= new_privacy >= 0:
            self.privacy_level = new_privacy
            self.value_per_infected = float(self.privacy_level / 100)


class Simulation:
    # constructor
    # graph, number_of_steps, start_infected, multihoming, mh_immunity and sim_id set the corresponding attributes
    # virus_variables provides both the variables for constructing the viruses and set the denominator
    def __init__(self, graph, number_of_steps=1000, start_infected=30, multihoming=False, mh_immunity=0.5,
                 virus_variables=(24, 332, 16, 332, 10000), privacy=False, sim_id=0):
        self.sim_id = sim_id  # id to distinguish parallel run simulations
        if self.sim_id != 0:
            print('Simulation #%d' % sim_id)
        self.graph = graph  # the network graph on which the simulation is run
        self.privacy = privacy
        if self.privacy:
            # initialising all nodes as healthy and having no cost from exploitation of user data
            self.graph.add_nodes_from(self.graph, infected1=0, infected2=0, privacy_cost=0)
            # TODO parameters for simulations using privacy levels have to be set here manually
            self.viruses = [Virus(1, virus_variables[0], virus_variables[1], privacy=75),
                            Virus(2, virus_variables[2], virus_variables[3], privacy=85)]
        else:
            # initialising all nodes as healthy
            self.graph.add_nodes_from(self.graph, infected1=0, infected2=0)
            self.viruses = [Virus(1, virus_variables[0], virus_variables[1]),
                            Virus(2, virus_variables[2], virus_variables[3])]  # stores the viruses in an array
        self.step = 0  # counts the number of steps taken so far
        self.start_infected = start_infected  # number of infected at the start per virus
        self.infection_after_step = []  # stores detailed (for each individual node) history TODO: Specify form
        self.multihoming = multihoming  # whether multihoming is possible
        if self.multihoming:
            self.simple_history = [[], [], [], []]
        else:
            self.simple_history = [[], [], []]  # saves simple (number of infected per virus) history in the form
            # [[step], [# of infected by virus 1 at step], [# of infected by virus 2 at step]]
        self.payout_history = [[], [], []]  # saves payout each step
        self.denominator = virus_variables[4]  # number the virus attack and cure rates are divided by
        # self.infection_mechanism = 'standard'  # standard
        self.number_of_steps = number_of_steps
        self.mh_immunity = mh_immunity  # how much an existing infection with one virus decreases the chance of another
        # virus infecting the same node when multihoming is activated (0 -> no interaction, 1 -> mutual immunity)
        # this is the parameter called 'mh' in the Bachelor's Thesis

        self.prepare_graph()

        # visualisation and possibly change of strategy after a defined number of time steps
        num_steps = int(self.number_of_steps/2)
        # self.draw_this()  # visualises the graph topology
        self.run_sim(num_steps)
        # self.draw_this()
        # TODO set parameters for change of strategy here:
        # self.viruses[0].attack_rate = 6
        # self.viruses[0].cure_rate = 15
        #self.viruses[0].set_privacy_level(80)
        # self.viruses[0].value_per_infected = 2
        self.run_sim(num_steps)
        # self.draw_this()

        plt.show()

    # sets up the graph before the first step
    def prepare_graph(self):
        self.distribute_infected(self.start_infected)
        if self.privacy:  # only if privacy is part of the simulation
            self.distribute_privacy_cost()  # this distributes the parameter called 'cP' in the Bachelor's Thesis

    # distributes <start_num> infected nodes per virus
    def distribute_infected(self, start_num):
        if start_num * 2 > self.graph.number_of_nodes():
            print("Choose a number of infected at the start lower or equal to half the number of nodes in the graph.")
            exit(-2)
        # starting nodes for each virus are generated randomly
        for v in self.viruses:
            for start_node in range(0, start_num):
                random_num = random.randint(0, self.graph.number_of_nodes() - 1)
                # collisions among generated starting nodes are avoided here (with multihoming only collisions with the
                # same virus are avoided)
                if not self.multihoming:
                    while self.is_infected_by(random_num) != 0:
                        random_num = random.randint(0, self.graph.number_of_nodes() - 1)
                else:
                    while self.is_infected_by(random_num) == v.number:
                        random_num = random.randint(0, self.graph.number_of_nodes() - 1)
                self.infect_node(random_num, v.number)

        # saves current state of infection in an array
        self.update_histories()

    # sets privacy cost for each node randomly between 0 and 100
    def distribute_privacy_cost(self):
        for node in self.graph.nodes:
            self.graph.nodes[node]['privacy_cost'] = random.randint(0, 100)

    # runs simulation for certain number of steps, by default 1
    def run_sim(self, total_steps=1):
        for s in range(0, total_steps):
            self.step += 1
            if not self.multihoming:
                marked = self.marking_mechanism_standard()
            else:
                marked = self.marking_mechanism_multihoming()
            marked_for_cure = marked[0]
            marked_for_infection = marked[1]

            # curing all marked nodes
            cure_from_virus = 1  # number of virus which the node is cured from
            for marked_by_virus in marked_for_cure:
                for node_to_cure in marked_by_virus:
                    self.cure_node(node_to_cure, cure_from_virus)
                cure_from_virus += 1

            # Resolves conflicts between viruses trying to infect the same node
            # Got moved to the marking mechanism
            # marked_by_0 = marked_for_infection[0].copy()
            # for m in marked_by_0:
            #    if marked_for_infection[1].__contains__(m):
            #        print("Collision")
            #        if random.randint(1, self.denominator) <= (self.viruses[0].attack_rate / (
            #                self.viruses[0].attack_rate + self.viruses[1].attack_rate)) * self.denominator:
            #            marked_for_infection[1].remove(m)
            #        else:
            #            marked_for_infection[0].remove(m)

            # infecting marked nodes
            infect_counter = 1
            for marked_by_virus in marked_for_infection:
                for m in marked_by_virus:
                    self.infect_node(m, infect_counter)
                infect_counter += 1
            # calculates payout
            self.calculate_payouts()
            # adds graph to history
            self.update_histories()
            # TODO This can set the new privacy level for virus 1 after virus 2 is extinct
            """new_privacy_level_v1 = 80
            if len(self.viruses[1].infected) == 0 and self.viruses[0].privacy_level != new_privacy_level_v1:
                self.viruses[0].set_privacy_level(new_privacy_level_v1)"""

    # visual representation of the graph using matplotlib
    def draw_this(self):
        plt.figure(self.step)
        # for graphical presentation
        width = 1
        if self.graph.number_of_nodes() >= 100:  # adjusts line width so big graphs are not cluttered
            width = 20 / self.graph.number_of_nodes()  # TODO: Find better solution
        color = self.infection_after_step[self.step]
        # parameters for visual representation can be set here:
        # choose a layout to make it consistent between steps (kamada_kawai_layout recommended)
        # with_labels draws each nodes name
        # node_color colors the nodes based on the infection status (virus 1 blue, virus 2 yellow, healthy purple)
        # vmin and vmax set the lower and upper bounds of possible infection statuses (this is important for consistency
        # if one virus dies off)
        nx.draw_networkx(self.graph, nx.kamada_kawai_layout(self.graph), with_labels=True, node_color=color,
                         vmin=0, vmax=2, width=width)

    # this is the standard mechanism
    # it does not apply multihoming or percentage infection
    # for each node:
    #   step 1: determine infection status
    #   step 2: choose whether it gets a new infection
    #   step 3: choose whether an existing infection is cured
    # this marking mechanism accounts for the number of infected neighbors per virus
    # does not apply multihoming
    def marking_mechanism_standard(self):
        marked_for_cure = []
        cure_of_virus_1 = []
        cure_of_virus_2 = []
        marked_for_infection = []
        infect_with_virus_1 = []
        infect_with_virus_2 = []
        for node in self.graph.nodes:
            # step 1
            infected_by = self.is_infected_by(node)
            # step 2
            if infected_by == 0:  # only healthy nodes might be infected
                infected_neighbors = self.number_of_infected_neighbors(node)
                privacy_cost = 0
                if self.privacy:
                    privacy_cost = self.graph.nodes[node]['privacy_cost']
                virus_1_attack_rate = self.calculate_attack_rate(infected_neighbors[0], 1, privacy_cost=privacy_cost)
                virus_2_attack_rate = self.calculate_attack_rate(infected_neighbors[1], 2, privacy_cost=privacy_cost)
                if not virus_1_attack_rate == 0:
                    if not virus_2_attack_rate == 0:  # infected neighbors of both types
                        # this if sorts out cases where neither virus infects the node
                        # chance of this happening: (1 - attack rate v1)*(1 - attack rate v2) in absolute numbers
                        chance_any_infection = self.denominator - ((self.denominator - virus_1_attack_rate) *
                                                                   (self.denominator - virus_2_attack_rate) /
                                                                   self.denominator)
                        if random.randint(1, self.denominator) <= chance_any_infection:
                            # the if/else decides which virus infects the node
                            # chances are proportional to the respective attack rates
                            if random.randint(1, self.denominator) <= (virus_1_attack_rate / (
                                    virus_1_attack_rate + virus_2_attack_rate)) * self.denominator:
                                infect_with_virus_1.append(node)
                            else:
                                infect_with_virus_2.append(node)
                    elif random.randint(1, self.denominator) <= virus_1_attack_rate:  # only v1 infected neighbors
                        infect_with_virus_1.append(node)
                elif not virus_2_attack_rate == 0:  # only v2 infected neighbors
                    if random.randint(1, self.denominator) <= virus_2_attack_rate:
                        infect_with_virus_2.append(node)
            # step 3
            else:
                if random.randint(1, self.denominator) <= \
                        self.viruses[infected_by - 1].cure_rate:
                    # marks cured nodes for removal from list of infected nodes
                    if infected_by == 1:
                        cure_of_virus_1.append(node)
                    elif infected_by == 2:
                        cure_of_virus_2.append(node)
        marked_for_cure.append(cure_of_virus_1)
        marked_for_cure.append(cure_of_virus_2)
        marked_for_infection.append(infect_with_virus_1)
        marked_for_infection.append(infect_with_virus_2)
        marked = [marked_for_cure, marked_for_infection]
        return marked

    # this is the multihoming mechanism
    # it does not apply percentage infection
    # for each node:
    #   step 1: determine infection status
    #   step 2: choose whether it gets a new infection
    #   step 3: choose whether an existing infection is cured
    # this marking mechanism accounts for the number of infected neighbors per virus
    def marking_mechanism_multihoming(self):
        marked_for_cure = []
        cure_of_virus_1 = []
        cure_of_virus_2 = []
        marked_for_infection = []
        infect_with_virus_1 = []
        infect_with_virus_2 = []
        for node in self.graph.nodes:
            # step 1 (status)
            infected_by = self.is_infected_by(node)
            # step 2 (infecting)
            if infected_by != 3:  # only nodes which are not already infected by both viruses might be infected
                infected_neighbors = self.number_of_infected_neighbors(node)
                if infected_by != 1:
                    privacy_cost = 0
                    if self.privacy:
                        privacy_cost = self.graph.nodes[node]['privacy_cost']
                    virus_1_attack_rate = self.calculate_attack_rate(infected_neighbors[0], 1, infected_by=infected_by,
                                                                     privacy_cost=privacy_cost)
                    if random.randint(1, self.denominator) <= virus_1_attack_rate:
                        infect_with_virus_1.append(node)
                if infected_by != 2:
                    privacy_cost = 0
                    if self.privacy:
                        privacy_cost = self.graph.nodes[node]['privacy_cost']
                    virus_2_attack_rate = self.calculate_attack_rate(infected_neighbors[1], 2, infected_by=infected_by,
                                                                     privacy_cost=privacy_cost)
                    if random.randint(1, self.denominator) <= virus_2_attack_rate:
                        infect_with_virus_2.append(node)
            # step 3 (curing)
            if infected_by == 1 or infected_by == 3:
                if random.randint(1, self.denominator) <= self.viruses[0].cure_rate:
                    cure_of_virus_1.append(node)
            if infected_by == 2 or infected_by == 3:
                if random.randint(1, self.denominator) <= self.viruses[1].cure_rate:
                    cure_of_virus_2.append(node)
        marked_for_cure.append(cure_of_virus_1)
        marked_for_cure.append(cure_of_virus_2)
        marked_for_infection.append(infect_with_virus_1)
        marked_for_infection.append(infect_with_virus_2)
        marked = [marked_for_cure, marked_for_infection]
        return marked

    # calculates attack rate from number of infected neighbors using math module
    # current implementation effectively tries for each infected neighbor to infect the node once with the viruses
    # attack rate
    # infected_by is used for calculating attack rate dependent on which virus(es) the node is already infected by
    # (only for infected_by != 0)
    def calculate_attack_rate(self, num_of_neighbors, virus_number, infected_by=0, privacy_cost=0):
        actual_rate = 0
        modifier = 1
        attack_happens = False
        if num_of_neighbors >= 1:
            if infected_by == 0:
                attack_happens = True
                # modifier does not change (modifier = modifier * 1)
            elif infected_by == virus_number or infected_by == 3:
                attack_happens = False
            # when there is already a different virus present the attack rate per node is reduced by partial immunity
            elif self.multihoming:
                attack_happens = True
                modifier = modifier * (1 - self.mh_immunity)
        if self.privacy:
            # at maximum user data exploitation and maximum privacy cost the chance of infection is 0
            # at minimum exploitation or cost the chance of infection is unchanged
            # at half exploitation and half cost the chance of infection is 3/4 of the base chance
            virus_privacy = self.viruses[virus_number - 1].privacy_level
            modifier = modifier * (1 - (virus_privacy * privacy_cost / 10000))

        if attack_happens:
            rate_per_neighbor = (self.denominator - self.viruses[virus_number - 1].attack_rate *
                                 modifier) / self.denominator
            actual_rate = self.denominator - math.pow(rate_per_neighbor, num_of_neighbors) * self.denominator
        return actual_rate

    # calculates payout for each virus
    def calculate_payouts(self):
        for v in self.viruses:
            num_infected = len(v.infected)
            if num_infected > 0:
                v.payout += num_infected * math.log(num_infected, 2) * v.value_per_infected  # Briscoe approximation
            # v.payout += len(v.infected) * v.value_per_infected

    # extracts infection information from current graph
    def get_infection_array(self):
        return np.asarray([self.is_infected_by(n) for n in self.graph.nodes])

    # counts infected per virus in current graph
    # returns array [current step, # of infected by virus1, # of infected by virus2]
    # nodes infected by both are counted towards infected by 1, 2 and both
    def get_current_infected(self):
        detailed_array = self.infection_after_step[self.step]
        infected_v1 = 0
        infected_v2 = 0
        infected_both = 0
        for n in detailed_array:
            if n == 1:
                infected_v1 += 1
            elif n == 2:
                infected_v2 += 1
            elif n == 3:
                infected_v1 += 1
                infected_v2 += 1
                infected_both += 1
            elif n > 3 or n < 0:
                print("A node had an infection status other than 0, 1, 2 or 3.")
        return [self.step, infected_v1, infected_v2, infected_both]

    # adds the current state to all histories
    def update_histories(self):
        self.infection_after_step.append(self.get_infection_array())
        current_infected = self.get_current_infected()
        relevant_entries = 3
        if self.multihoming:
            relevant_entries = 4
        for x in range(0, relevant_entries):
            self.simple_history[x].append(current_infected[x])
        self.payout_history[0].append(self.step)
        self.payout_history[1].append(self.viruses[0].payout)
        self.payout_history[2].append(self.viruses[1].payout)

    # returns which (if any) virus a node is infected by (0 == not infected, 1 == infected by v1, 2 == infected by v2,
    # 3 == infected by both)
    def is_infected_by(self, node):
        result = 0
        if self.graph.nodes[node]['infected1'] > 0:
            result += 1
        if self.graph.nodes[node]['infected2'] > 0:
            result += 2
        return result

    # counts the number of infected neighbors by each virus for a given node
    def number_of_infected_neighbors(self, node):
        result = [0, 0]
        for neighbor in self.graph.adj[node]:
            neighbor_virus = self.is_infected_by(neighbor)
            if neighbor_virus == 1:
                result[0] += 1
            elif neighbor_virus == 2:
                result[1] += 1
            # neighboring nodes infected by both are counted here
            elif neighbor_virus == 3:
                result[0] += 1
                result[1] += 1
        return result

    # adds node to list of infected nodes for <virus> and sets infection level in graph to 100 for <virus>
    def infect_node(self, node_num, virus):
        if not self.viruses[virus - 1].infected.__contains__(node_num):
            self.viruses[virus - 1].infected.append(node_num)
        if virus == 1:
            self.graph.nodes[node_num]['infected1'] = 100
        elif virus == 2:
            self.graph.nodes[node_num]['infected2'] = 100
        else:
            print("Please enter virus number as integer 1 or 2.")

    # removes node from list of infected nodes for <virus> and sets infection level in graph to 0 for <virus>
    def cure_node(self, node_num, virus):
        self.viruses[virus - 1].infected.remove(node_num)
        if virus == 1:
            self.graph.nodes[node_num]['infected1'] = 0
        elif virus == 2:
            self.graph.nodes[node_num]['infected2'] = 0
        else:
            print("Please enter virus number as integer 1 or 2.")
